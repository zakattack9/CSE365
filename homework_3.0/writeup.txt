Level 1: read through source code of the level 1 executable to see what plain-text password string the program is comparing the first input parameter to
Level 2: created a symbolic link (ln -s) to the level 2 executable where the linked file name is the password being compared
Level 3: created a symbolic link to the level 3 executable where the linked file name was the password being compared; needed to add the home (~) directory to the PATH so that the linked file could be executed without ./
Level 4: read through source code of the level 4 executable to find the plain-text password that was converted to an MD5 hash; the first input parameters just needed to match the plain-text password since it would be converted to the same MD5 hash that is was being checked against
Level 5: read through source code of the level 5 executable to find the hashed password; because MD5 will always produce the same hash for the same input, the hashed MD5 password just needed to be reversed back to its plain-text (used https://md5.gromweb.com/)
Level 6: since strlen() measures the length of a string up until a null character, a string starting with 00 (null in ASCII) will result in a length of 0; the first byte of the md5 hashed string "j(R1wzR*y[^GxWJ5B>L{-HLETRD" will by the null terminating character, thus when doing strncmp it will compare 0 characters and return 0
Level 7: since the md5 hash that user input being checked against is not a real string, we need to forcefully inject the md5 hash that level 7 is checking against; Fish's provided predict_filenames_and_write() code will predict the next 50 filenames that level 7 will generate and write the correct hash to each file in an infinite loop; since level 7, when run, will write/read from at least one of these files, we are guaranteed to have the correct hash injected into the right file since the loop will continuously replace the all of the next 50 potential files during the sleep(2).
Level 8: since .secret must be read from the home directory, we need to create a symlink from the ~/.secret to the .secret file in level 8/; when level 8 executable is run, the .secret file will be compared to itself and bring up a shell
Level 9: created a symlink form the .secret file in level 9/ to the home directory and then ran the level 9 executable from the home directory; this allowed the level 9 executable to create the level 9_secret and read/write from .secret
Level 10: this level  requires setting a BASE env variable; since the level 10 executable tries to append /.secret to the end of BASE, BASE should be set to /var/challenge/level 10; once the BASE variable is properly exported, the level 10 executable can be simply run to bring up a shell
Level 11: the same exploit for level 10 was used to pass this level  where the BASE env variable was set to /var/challenge/level 11
Level 12: the same exploit for level 10/11 was used to pass this level  where the BASE env variable was set to /var/challenge/level 12
Level 13: since this level  requires a BASE variable that does not point to a symlinked .secret file, we must instead have BASE point to another .secret file that was created in ~; when running the level 13 executable, this will bypass the BASE variable check, the realpath() check, and the symlink check; after passing all these checks the program will sleep for 5 seconds in which we remove the .secret in ~ and replace it with a new .secret that is a symlink to /level 13/.secret, this way when the program exits sleep, it will be reading from the correct .secret file
Level 14: since the executable takes the user's input and adds it directly into a command later executed, we can pass in l33t to the executable to have it run after executing the hardcoded command in the program; when a semicolon is passed into a command it acts like the & CLI operator but will execute its following command regardless if the previous command fails to execute; the final command is ./14 "test;l33t" where test is needed to flush the required input for tidy
Level 15: uses the same exploit as level 14 except the entire command is wrapped in ""; to bypass this we must use escape quotes such that the wrapper quotations wrap nothing; passing in "\" test;l33t \"" will result in the final string being "" test;l33t "" where test;l33t is no longer wrapped in quotes
Level 16: uses the same exploit as level 14/15 except we can no longer wrapper or command injection in quotes; an alternative is to use $() where anything inside the parenthesis will be run as command even when in a string; as a side note, '$(test;l33t)' must be passed in with single quotes, otherwise test;l33t will execute before running the level 16 executable
Level 17: since the executable makes a call to tidy, we can create a symlink in ~ directory called tidy that points to /bin/sh to open up a shell when running tidy; since the real tidy package exists elsewhere on the machine, we need to append the ~ directory that has our symlinked tidy executable to the start of our PATH variable such that when calling tidy, the tidy found in ~ will be executed first since the ~ directory is at the start of the PATH variable and will be searched for the tidy executable prior to other directories
Level 18: the exploit was similar to level 17 except the tidy executable was symlinked directly to l33t; the level 18 executable was then called and the symlinked tidy executable in the ~ directory was passed in; this resulted in l33t directly being called and access being granted to the next level 
Level 19: this exploit was the same as level 16 and '$(l33t)' was passed into the level 19 executable where single quotes were need to prevent the execution of l33t before the executable
Level 20: since the first command that level 20 executes will fail, we can use || to run another command; we can pass in l33t after the || "||(l33t)" so that l33t runs once the first command fails
Level 21: since | is filtered we can use && to pass l33t as a command that runs after the command in the level 21 executable; we must also escape the first & character when passing in the command "\&&(l33t)"
Level 22: used the same exploit as level 21 and passed in "\&&(l33t)" as the argument
Level 23: used the same exploit as level 21/22 and passed in "\&&(l33t)" as the argument
Level 24: created a symlink from the l33t executable to a l33t file in ~ directory; -exec l33t {} + allows execution of l33t on the files found with find /home; '"home -exec l33t {} +"' needed to be wrapped in single quotes to bypass the double quotes
Level 25: since the symlink from level 24 was not deleted, "home -exec l33t {} +" could be passed in without the need to escape the double quotes
Level 26: since the passed in command after -exec can not be l33t, another symlink to /usr/local/bin/l33t was made but under the name of haha; this new symlink needed to be passed in the same way as level 24 '"home -exec haha {} +"'
Level 27: running ./27 0d 401177 executed the give_me_a_shell function upon exiting at the end of main; 401177 was the address of give_me_a_shell and 0d was the brute forced offset of the original return address at the end of main
Level 28: running ./28 09 13371337 will replace the flag variable at the frame offset 09 with the value 13371337, this is the value that the flag is checked against to open the shell
Level 29: running ./29 004034a0 13371337 will replace the global flag variable at the memory address 004034a0 with the value 13371337, which is the value that the flag is checked against to open the shell
Level 30: using the after lecture video, shellcode was first exported to an environment variable; after getting the current stack pointer from ./30 python3 was used to get the hex representation of the stack pointer + 0x10000 (shellcode); the hex address calculated in python3 replaced the value that was at index 11 (return address)
Level 31: since the variable is_god was located after the 32 byte buffer variable, a string that was longer than 32 bytes needed to be provided to the level 31 executable; this would result in the long string overflowing into is_god which as a result would make is_god true when performing the conditional to open the shellcode
Level 32: the first 32 bytes of the passed in string was stored in a variable buffer that would be converted to an MD5 hash and later stored in checksum_0; there was a 32 byte gap between the buffer and checksum_1 variable so an additional 32 bytes of random characters were appended to the end of the buffer string; the MD5 hashed version of the buffer string was then appended to the end of the 32 bytes of random characters which overflowed into checksum_1; the final passed in string looked somthing like ./32 b9c1dcb84084183ea55ebfe2bb077f82aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa80686cb5f095cc18b814f3a10aae5571
Level 33: using a similar exploit to level 32 this level  required having a passed in string that was longer than 32 bytes but the first 32 bytes still needed to start with 00 (null) when hashed; ./33 185aaaaaaaaaaaaaaaaaaaaaaaaaaaaa was the string used to get the shellcode
Level 34: by passing in a long string that ended in l33t both the buffer and filename buffers could be overwritten later leading to execution of l33t in the code; ./34 ls aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaal33t
Level 35: similar to level 31, a really long string was passed into the executable so that it overflowed from the buffer variable into the checksum_1 and is_god variable; this allowed is_god to evaluate to true when executing the conditional that opened the shell
Level 36: watching Fish's demo 10 after-lecture the provided code was used to pass this level: ./36 $(python2 -c "print('185aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x01\xd2\xa5\x78\xc3\x74\x90\xa9\xd7\x23\x65\x99\x1b\x76\x60\x52')")
Level 37: the same string and command used in level 34 was used again to exploit this level ./37 ls aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaal33t